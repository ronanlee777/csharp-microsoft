//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "pch.h"
#include "ProgressRingIndeterminate.h"
#include "WindowsNumerics.h"

using namespace winrt::Microsoft::UI::Xaml::Controls;
using namespace winrt::Windows::Foundation;
using namespace winrt::Windows::Foundation::Metadata;
using namespace winrt::Windows::Foundation::Numerics;
using namespace winrt::Windows::Graphics;
using namespace winrt::Windows::UI;
using namespace winrt::Windows::UI::Composition;

namespace
{
    static void StartProgressBoundAnimation(
        CompositionObject target,
        winrt::hstring animatedPropertyName,
        CompositionAnimation animation,
        ExpressionAnimation controllerProgressExpression)
    {
        target.StartAnimation(animatedPropertyName, animation);
        const auto controller = target.TryGetAnimationController(animatedPropertyName);
        controller.Pause();
        controller.StartAnimation(L"Progress", controllerProgressExpression);
    }

    class AnimatedVisual
        : public winrt::implements<AnimatedVisual, winrt::IAnimatedVisual, winrt::IClosable>
    {
        // Animation duration: 2.000 seconds.
        static constexpr int64_t c_durationTicks{ 20000000L };
        Compositor const _c{ nullptr };
        ExpressionAnimation const _reusableExpressionAnimation{ nullptr };
        CompositionPropertySet const _themeProperties{ nullptr };
        CubicBezierEasingFunction _cubicBezierEasingFunction_0{ nullptr };
        StepEasingFunction _holdThenStepEasingFunction{ nullptr };
        ContainerVisual _root{ nullptr };
        ExpressionAnimation _rootProgress{ nullptr };
        CompositionColorBrush _themeColor_Foreground_0{ nullptr };
        CompositionColorBrush _themeColor_Foreground_1{ nullptr };

        void BindProperty(
            CompositionObject target,
            winrt::hstring animatedPropertyName,
            winrt::hstring expression,
            winrt::hstring referenceParameterName,
            CompositionObject referencedObject)
        {
            _reusableExpressionAnimation.ClearAllParameters();
            _reusableExpressionAnimation.Expression(expression);
            _reusableExpressionAnimation.SetReferenceParameter(referenceParameterName, referencedObject);
            target.StartAnimation(animatedPropertyName, _reusableExpressionAnimation);
        }

        // Layer (Shape): Radial
        CompositionContainerShape ContainerShape_0()
        {
            const auto result = _c.CreateContainerShape();
            result.TransformMatrix({ 1.76999998F, 0.0F, 0.0F, 1.76999998F, 16.0F, 16.0F });
            // Transforms: Radial
            result.Shapes().Append(ContainerShape_1());
            return result;
        }

        // Layer (Shape): Radial
        // Transforms for Radial
        CompositionContainerShape ContainerShape_1()
        {
            const auto result = _c.CreateContainerShape();
            const auto shapes = result.Shapes();
            // Ellipse Path / ShapeGroup: Ellipse B
            shapes.Append(SpriteShape_1());
            // Ellipse Path / ShapeGroup: Ellipse A
            shapes.Append(SpriteShape_2());
            StartProgressBoundAnimation(result, L"RotationAngleInDegrees", RotationAngleInDegreesScalarAnimation_0_to_900(), _rootProgress);
            return result;
        }

        CubicBezierEasingFunction CubicBezierEasingFunction_0()
        {
            return _cubicBezierEasingFunction_0 = _c.CreateCubicBezierEasingFunction({ 0.166999996F, 0.166999996F }, { 0.833000004F, 0.833000004F });
        }

        // Ellipse Path / ShapeGroup: Ellipse / Transforms: Radial BG / Layer (Shape): Radial
        // BG
        // Ellipse Path.EllipseGeometry
        CompositionEllipseGeometry Ellipse_9_0()
        {
            const auto result = _c.CreateEllipseGeometry();
            result.Radius({ 8, 8 });
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse B
        // Ellipse Path.EllipseGeometry
        CompositionEllipseGeometry Ellipse_9_1()
        {
            const auto result = _c.CreateEllipseGeometry();
            result.TrimEnd(0.5F);
            result.Radius({ 8, 8 });
            StartProgressBoundAnimation(result, L"TrimStart", TrimStartScalarAnimation_0_to_0p5(), RootProgress());
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse A
        // Ellipse Path.EllipseGeometry
        CompositionEllipseGeometry Ellipse_9_2()
        {
            const auto result = _c.CreateEllipseGeometry();
            result.Radius({ 8, 8 });
            StartProgressBoundAnimation(result, L"TrimEnd", TrimEndScalarAnimation_0_to_0p5(), _rootProgress);
            return result;
        }

        StepEasingFunction HoldThenStepEasingFunction()
        {
            const auto result = _holdThenStepEasingFunction = _c.CreateStepEasingFunction();
            result.IsFinalStepSingleFrame(true);
            return result;
        }

        // Opacity0
        ScalarKeyFrameAnimation Opacity0ScalarAnimation_0_to_1()
        {
            const auto result = _c.CreateScalarKeyFrameAnimation();
            result.Duration(TimeSpan{ c_durationTicks });
            result.InsertKeyFrame(0, 0, _holdThenStepEasingFunction);
            result.InsertKeyFrame(0.5F, 1, _holdThenStepEasingFunction);
            return result;
        }

        // Opacity0
        ScalarKeyFrameAnimation Opacity0ScalarAnimation_1_to_0()
        {
            const auto result = _c.CreateScalarKeyFrameAnimation();
            result.Duration(TimeSpan{ c_durationTicks });
            result.InsertKeyFrame(0, 1, _holdThenStepEasingFunction);
            result.InsertKeyFrame(0.5F, 0, _holdThenStepEasingFunction);
            return result;
        }

        // The root of the composition.
        ContainerVisual Root()
        {
            const auto result = _root = _c.CreateContainerVisual();
            const auto propertySet = result.Properties();
            propertySet.InsertScalar(L"Progress", 0);
            result.Children().InsertAtTop(ShapeVisual_0());
            return result;
        }

        ExpressionAnimation RootProgress()
        {
            const auto result = _rootProgress = _c.CreateExpressionAnimation(L"_.Progress");
            result.SetReferenceParameter(L"_", _root);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Rotation
        ScalarKeyFrameAnimation RotationAngleInDegreesScalarAnimation_0_to_900()
        {
            const auto result = _c.CreateScalarKeyFrameAnimation();
            result.Duration(TimeSpan{ c_durationTicks });
            result.InsertKeyFrame(0, 0, _holdThenStepEasingFunction);
            result.InsertKeyFrame(0.5F, 450, _cubicBezierEasingFunction_0);
            result.InsertKeyFrame(1, 900, _cubicBezierEasingFunction_0);
            return result;
        }

        ShapeVisual ShapeVisual_0()
        {
            const auto result = _c.CreateShapeVisual();
            result.Size({ 32, 32 });
            const auto shapes = result.Shapes();
            // Ellipse Path / ShapeGroup: Ellipse / Transforms: Radial BG / Layer (Shape): Radial
            // BG
            shapes.Append(SpriteShape_0());
            // Layer (Shape): Radial
            shapes.Append(ContainerShape_0());
            return result;
        }

        // Ellipse Path
        CompositionSpriteShape SpriteShape_0()
        {
            const auto result = _c.CreateSpriteShape(Ellipse_9_0());
            result.TransformMatrix({ 1.76999998F, 0.0F, 0.0F, 1.76999998F, 16.0F, 16.0F });
            result.StrokeBrush(ThemeColor_Background());
            result.StrokeDashCap(CompositionStrokeCap::Round);
            result.StrokeEndCap(CompositionStrokeCap::Round);
            result.StrokeStartCap(CompositionStrokeCap::Round);
            result.StrokeMiterLimit(4);
            result.StrokeThickness(2);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path
        CompositionSpriteShape SpriteShape_1()
        {
            const auto result = _c.CreateSpriteShape(Ellipse_9_1());
            result.StrokeBrush(ThemeColor_Foreground_0());
            result.StrokeDashCap(CompositionStrokeCap::Round);
            result.StrokeEndCap(CompositionStrokeCap::Round);
            result.StrokeStartCap(CompositionStrokeCap::Round);
            result.StrokeMiterLimit(4);
            result.StrokeThickness(2);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path
        CompositionSpriteShape SpriteShape_2()
        {
            const auto result = _c.CreateSpriteShape(Ellipse_9_2());
            result.StrokeBrush(ThemeColor_Foreground_1());
            result.StrokeDashCap(CompositionStrokeCap::Round);
            result.StrokeEndCap(CompositionStrokeCap::Round);
            result.StrokeStartCap(CompositionStrokeCap::Round);
            result.StrokeMiterLimit(4);
            result.StrokeThickness(2);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse B
        // Ellipse Path.EllipseGeometry
        // TrimStart
        StepEasingFunction StepThenHoldEasingFunction()
        {
            const auto result = _c.CreateStepEasingFunction();
            result.IsInitialStepSingleFrame(true);
            return result;
        }

        // Ellipse Path / ShapeGroup: Ellipse / Transforms: Radial BG / Layer (Shape): Radial
        // BG
        // Color bound to theme property value: Background
        CompositionColorBrush ThemeColor_Background()
        {
            const auto result = _c.CreateColorBrush();
            BindProperty(result, L"Color", L"ColorRGB(_theme.Background.W,_theme.Background.X,_theme.Background.Y,_theme.Background.Z)", L"_theme", _themeProperties);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse B
        // Color bound to theme property value: Foreground
        CompositionColorBrush ThemeColor_Foreground_0()
        {
            const auto result = _themeColor_Foreground_0 = _c.CreateColorBrush();
            const auto propertySet = result.Properties();
            propertySet.InsertScalar(L"Opacity0", 0);
            _reusableExpressionAnimation.ClearAllParameters();
            _reusableExpressionAnimation.Expression(L"ColorRGB(_theme.Foreground.W * my.Opacity0,_theme.Foreground.X,_theme.Foreground.Y,_theme.Foreground.Z)");
            _reusableExpressionAnimation.SetReferenceParameter(L"my", propertySet);
            _reusableExpressionAnimation.SetReferenceParameter(L"_theme", _themeProperties);
            result.StartAnimation(L"Color", _reusableExpressionAnimation);
            StartProgressBoundAnimation(propertySet, L"Opacity0", Opacity0ScalarAnimation_0_to_1(), _rootProgress);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse A
        // Color bound to theme property value: Foreground
        CompositionColorBrush ThemeColor_Foreground_1()
        {
            const auto result = _themeColor_Foreground_1 = _c.CreateColorBrush();
            const auto propertySet = result.Properties();
            propertySet.InsertScalar(L"Opacity0", 1);
            _reusableExpressionAnimation.ClearAllParameters();
            _reusableExpressionAnimation.Expression(L"ColorRGB(_theme.Foreground.W * my.Opacity0,_theme.Foreground.X,_theme.Foreground.Y,_theme.Foreground.Z)");
            _reusableExpressionAnimation.SetReferenceParameter(L"my", propertySet);
            _reusableExpressionAnimation.SetReferenceParameter(L"_theme", _themeProperties);
            result.StartAnimation(L"Color", _reusableExpressionAnimation);
            StartProgressBoundAnimation(propertySet, L"Opacity0", Opacity0ScalarAnimation_1_to_0(), _rootProgress);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse A
        // Ellipse Path.EllipseGeometry
        // TrimEnd
        ScalarKeyFrameAnimation TrimEndScalarAnimation_0_to_0p5()
        {
            const auto result = _c.CreateScalarKeyFrameAnimation();
            result.Duration(TimeSpan{ c_durationTicks });
            result.InsertKeyFrame(0, 9.99999975E-05F, _holdThenStepEasingFunction);
            result.InsertKeyFrame(0.5F, 0.5F, _cubicBezierEasingFunction_0);
            return result;
        }

        // Layer (Shape): Radial
        // Transforms: Radial
        // Ellipse Path / ShapeGroup: Ellipse B
        // Ellipse Path.EllipseGeometry
        // TrimStart
        ScalarKeyFrameAnimation TrimStartScalarAnimation_0_to_0p5()
        {
            const auto result = _c.CreateScalarKeyFrameAnimation();
            result.Duration(TimeSpan{ c_durationTicks });
            result.InsertKeyFrame(0, 0, StepThenHoldEasingFunction());
            result.InsertKeyFrame(0.5F, 0, HoldThenStepEasingFunction());
            result.InsertKeyFrame(1, 0.5F, CubicBezierEasingFunction_0());
            return result;
        }

    public:
        AnimatedVisual(Compositor compositor, CompositionPropertySet themeProperties)
            : _c(compositor)
            , _themeProperties(themeProperties)
            , _reusableExpressionAnimation(compositor.CreateExpressionAnimation())
        {
            const auto _ = Root();
        }

        void Close()
        {
            if (_root)
            {
                _root.Close();
            }
        }

        TimeSpan Duration() const
        {
            return { TimeSpan{ c_durationTicks } };
        }


        Visual RootVisual() const
        {
            return _root;
        }


        float2 Size() const
        {
            return { 32, 32 };
        }

        static bool IsRuntimeCompatible()
        {
            return ApiInformation::IsApiContractPresent(L"Windows.Foundation.UniversalApiContract", 7);
        }
    };
} // end namespace

CompositionPropertySet AnimatedVisuals::ProgressRingIndeterminate::EnsureThemeProperties(Compositor compositor)
{
    if (_themeProperties == nullptr)
    {
        _themeProperties = compositor.CreatePropertySet();
        _themeProperties.InsertVector4(L"Background", { 211, 211, 211, 255 });
        _themeProperties.InsertVector4(L"Foreground", { 0, 120, 215, 255 });
    }
    return _themeProperties;
}

CompositionPropertySet AnimatedVisuals::ProgressRingIndeterminate::GetThemeProperties(Compositor compositor)
{
    return EnsureThemeProperties(compositor);
}

IAnimatedVisual AnimatedVisuals::ProgressRingIndeterminate::TryCreateAnimatedVisual(
    const Compositor& compositor,
    IInspectable& diagnostics)
{
    const auto _ = EnsureThemeProperties(compositor);
    diagnostics = nullptr;

    if (AnimatedVisual::IsRuntimeCompatible())
    {
        return winrt::make<AnimatedVisual>(compositor, _themeProperties);
    }

    return nullptr;
}
